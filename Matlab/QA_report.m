%% DTI QA 
% Summary of QA on DTI data in HUNT 
% The QA data is generated by the 'dtiQA.m' script 
% We define outlies a 3 std from the mean
nStd = 3;
%% Check the DTI brainmask
% Here we compare the DTI brainmask volumes to the T1 brainmask volumes and
% compute the overlap of these. The msimatch volume is the non-overlapping
% volume.
BX=zeros(numel(QA),3);
for i=1:numel(QA),
    BX(i,:) = [QA(i).maskVol.dtiMask QA(i).maskVol.t1Mask QA(i).maskVol.mismatch];
end
figure, 
boxplot(BX,'labels',{'DTI mask','T1 mask','mismatch'})
snapnow;
outliers = findOutliers(BX(:,3),nStd);
% if ~isempty(outliers),
%     ol = table(QA(outliers).id,QA(outliers).maskVol.dtiMask,QA(outliers).maskVol.t1Mask, QA(outliers).maskVol.mismatch,...
%         'VariableNames',{'ID','DTI mask','T1 mask','Mismatch'});
%     disp(ol)
% else
%     fprintf('*No outliers found!*\n');
% end

%% Check motion
% look at the scan-scan motion
scans = (1:numel(QA(1).movParam.param(:,1)));
figure,
colVec =['b';'r';'g']
titleVect = {'Trans X'; 'Trans Y'; 'Trans Z'};
for j=1:3,
   h(j) = subplot(3,1,j);
end
for i=1:numel(QA),;
    for j=1:3,
    hold on
       subplot(h(j)), scatter(scans,QA(i).movParam.param(:,j),'MarkerFaceColor',colVec(j),'MarkerEdgeColor',colVec(j),...
        'MarkerFaceAlpha',.2,'MarkerEdgeAlpha',.2);
    hold off
    end
end
for j=1:3,
   h(j).Title.String = titleVect{j};
end


snapnow;


figure,
hold on
for i=1:numel(QA),
    scatter(scans,QA(i).movParam.param(:,4),'MarkerFaceColor','m','MarkerEdgeColor','m',...
        'MarkerFaceAlpha',.2,'MarkerEdgeAlpha',.2);
    scatter(scans,QA(i).movParam.param(:,5),'MarkerFaceColor','y','MarkerEdgeColor','y',...
        'MarkerFaceAlpha',.2,'MarkerEdgeAlpha',.2);
    scatter(scans,QA(i).movParam.param(:,6),'MarkerFaceColor','k','MarkerEdgeColor','k',...
        'MarkerFaceAlpha',.2,'MarkerEdgeAlpha',.2);
end
title('Rotations');
hold off
snapnow;

%% Plot box plot of average scan-to-scan movement parameters 
BX=zeros(numel(QA),6);
nTp = numel(QA(1).movParam.param(:,1));
for i=1:numel(QA),
    for j=1:6,
        BX(i,j) = mean(diff(QA(i).movParam.param(:,j)));
    end
end
figure, 
boxplot(BX(:,1:3),'labels',{'dx','dy','dz'})
title('Translation');
snapnow;
figure, 
boxplot(BX(:,4:6),'labels',{'drx','dry','drz'})
title('Rotation');
snapnow;

%% Scan-to-scan displacement
% We compute the scan-scan displacement as norm(dx,dy,dz) and look for
% outliers. This could also be done for the rotations, but it is a bit
% tricky to calculate the Euler angle, so we assume that large rotations
% will be associated with large translations. 

displ = zeros(numel(QA),nTp-1);
d = zeros(nTp-1,1);
for i=1:numel(QA),
    dx = diff(QA(i).movParam.param(:,1));
    dy = diff(QA(i).movParam.param(:,2));
    dz = diff(QA(i).movParam.param(:,3));
    for j=1:(nTp-1),
        displ(i,j) = norm([dx(j) dy(j) dz(j)]);
    end
end
scans = [1:numel(dx)];
figure,
hold on
for i=1:numel(QA),
    scatter(scans,displ(i,:)','MarkerFaceColor','b','MarkerEdgeColor','b','MarkerFaceAlpha',.2,'MarkerEdgeAlpha',.2);
end
hold off
title('Scan-to-scan displacement');
snapnow;

%% Outliers in scan-to-scan diplacement
% There is a large "jump" in the z-displacment
% between the non-diffusion weighted images and the diffusion weighted
% images. This jump cause a large displacement at index 5 which makes it difficult to detect
% ouliers. We therefore remove datapoint 5 from the displacement data and
% check for outliers in the remaining data.

displOl = displ(:,[1:4,6:end]);

BX = max(abs(displOl),[],2);
boxplot(BX,'labels',{'disp'})
title('Max Displacement');
snapnow;

outliers = findOutliers(displOl,2*nStd);
olID = getHuntId(outliers,QA);
if ~isempty(outliers),
    ol = table(olID',mean(displOl(outliers,:),2),min(displOl(outliers,:),[],2),max(displOl(outliers,:),[],2),...
        'VariableNames',{'ID','meanDispl','minDispl','maxDispl'});
    disp(ol)
else
    fprintf(' *No outliers found!*\n');
end

%% Check average signal in GM and WM
scans=[1:numel(QA(1).dti.gmTs)];
figure,
hold on
for i=1:numel(QA),
  scatter(scans,QA(i).dti.gmTs,'MarkerFaceColor','b','MarkerEdgeColor','b','MarkerFaceAlpha',.2,'MarkerEdgeAlpha',.2);
  scatter(scans,QA(i).dti.wmTs,'MarkerFaceColor','r','MarkerEdgeColor','r','MarkerFaceAlpha',.2,'MarkerEdgeAlpha',.2);
end
hold off

%% Detect outliers in WM signal 
% The WM signal is markedly different between the non diffusion weighted
% scans and the diffusion weighted scans. Therefore we have to check these
% separately for outliers.
nScans = numel(QA(1).dti.wmTs);
b0WM=zeros(numel(QA),5);
dtWM=zeros(numel(QA),nScans-5);
for i=1:numel(QA),
  b0WM(i,:) = QA(i).dti.wmTs(1:5);
  dtWM(i,:) = QA(i).dti.wmTs(6:end);  
end

%% Outliers in B0 scans
outliers = findOutliers(b0WM,nStd);
olID = getHuntId(outliers,QA);
if ~isempty(outliers),
    ol = table(olID',mean(b0WM(outliers,:),2),min(b0WM(outliers,:),[],2),max(b0WM(outliers,:),[],2),...
        'VariableNames',{'ID','meanWM','minWM','maxWM'});
    disp(ol)
else
    fprintf(' *No outliers found!*\n');
end

%% Outliers in DW scans
outliers = findOutliers(dtWM,4);
olID = getHuntId(outliers,QA);
if ~isempty(outliers),
    ol = table(olID',mean(dtWM(outliers,:),2),min(dtWM(outliers,:),[],2),max(dtWM(outliers,:),[],2),std(dtWM(outliers,:),[],2),...
        median(dtWM(outliers,:),2), 'VariableNames',{'ID','meanWM','minWM','maxWM','std','median'});
    disp(ol)
else
    fprintf(' *No outliers found!*\n');
end

%% Slice dropouts
% Slice dropout are identified as slices where the signal from GM in the DW
% images are more than 3std from the mean. The B0 and diffusion weighted
% images are treated seperately.  The GM mask is from the spm-T1
% segmentation and is resampled into the DTI image space. The rationale for
% using a GM mask is that the GM signal is relatively stable in DW images
% compared to the WM signal, and it might therefore be easier to detect
% slice dropouts in the GM signal. 

count = 0;
outliers=[];
numOutliers=[];
nSlices = 60;
for i = 1:numel(QA),
    sliceOutlier=[];
    olc= 0;
    for j=1:nSlices,        
        if ~all(QA(i).dti.sliceIntensity(6:end,j) == 0)
            sliceOutlier = findOutliers(QA(i).dti.sliceIntensity(6:end,j),6);
            if ~isempty(sliceOutlier),
                olc = olc + 1;                 
            end
        end
    end
    if olc > 0,
        count=count+1;
        outliers(count)= i;
        numOutliers(count) = olc;
    end
end
olID = getHuntId(outliers,QA);
 if ~isempty(outliers)
      ol = table(olID',numOutliers','VariableNames',{'ID','NumOutliers'});
      disp(ol)
 else
       fprintf(' *No outliers found!*');   
 end

%% Visualize slice intensities
% here
nSubj = numel(QA);
nMat = ceil(sqrt(nSubj));
% we construct a nMat*nMat "supergrid" to hold the data.
% Each element in the supergrid is 45*60 pixels, that is 45 slices * 60
% dwi volumes. 
% 
im= zeros(nMat*45,nMat*60,'single');
%subIm = zeros(45,60);
count = 1;
for i=1:nMat,
    for j=1:nMat,
        im((i-1)*45+1:(i-1)*45+45,(j-1)*60+1:(j-1)*60+60) = QA(count).dti.sliceIntensity;               
        count=count+1;
        if count > nSubj,
            break
        end
    end
    if count > nSubj,
           break
    end
end
figure,
imshow(im,[],'Border','tight','Colormap',hot(256))
snapnow


%% Mean intensity and STD plots
% 
scans=(1:numel(QA));
plotVal = zeros(numel(QA),1);
ylabels = {'FA','FA_GM','FA_WM','MD','MD_GM','MD_WM','SSE','SSE_GM','SSE_WM'};
xlabels = {'imMean','imNonzeroMean','imStd'}; 
for j=1:numel(ylabels);
    figure,
    for k = 1:numel(xlabels),
        for i =1:numel(QA),
            plotVal(i) = QA(i).dti.stats{ylabels(j),xlabels(k)}; % curly braces retur array not table!
        end
        subplot(1,3,k), scatter(scans,plotVal,8,'MarkerFaceColor','b','MarkerEdgeColor','b','MarkerFaceAlpha',.2,...
            'MarkerEdgeAlpha',.2);
        title([ylabels{j} ' ' xlabels{k}],'Interpreter','none');
    end
    snapnow
end



%% end
close('all')
  